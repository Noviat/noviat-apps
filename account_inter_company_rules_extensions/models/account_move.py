# Copyright 2009-2023 Noviat.
# License LGPL-3.0 or later (http://www.gnu.org/licenses/lgpl).

import logging

from odoo import _, api, fields, models
from odoo.exceptions import UserError

_logger = logging.getLogger(__name__)


class AccountMove(models.Model):
    _inherit = "account.move"

    auto_generated = fields.Boolean(
        help="This flag is set when this invoice is an auto_generated Intercompany Invoice."
    )

    # the account_inter_company_rules module add a link from
    # the autogenerated invoice to the source invoice but
    # not the other way around.
    # We also need a link from the source invoice to the target
    # invoice in order to add some extra controls.
    # E.g. the standard account_inter_company_rules module
    # allows to set an intercompany module to draft and reconfirm
    # whereby every reconfirm generates again an intercompany invoice.
    intercompany_invoice_id = fields.Many2one(
        comodel_name="account.move",
        string="Intercompany Invoice",
        readonly=True,
        copy=False,
        help="Incoming invoice in Customer's Company.",
    )
    intercompany_invoice = fields.Boolean(
        string="Intercompany Invoice Source",
        store=True,
        compute="_compute_intercompany_invoice",
        compute_sudo=True,
        help="This flag is set when this invoice " "is an Intercompany Invoice.",
    )
    intercompany_invoice_ref = fields.Char(
        string="Intercompany Invoice Number",
        store=True,
        compute="_compute_intercompany_invoice_ref",
        compute_sudo=True,
    )

    @api.depends("intercompany_invoice_id")
    def _compute_intercompany_invoice(self):
        for rec in self:
            if rec.intercompany_invoice_id:
                rec.intercompany_invoice = True
            else:
                rec.intercompany_invoice = False

    @api.depends(
        "intercompany_invoice_id",
        "auto_invoice_id",
        "intercompany_invoice_id.state",
        "auto_invoice_id.state",
    )
    def _compute_intercompany_invoice_ref(self):
        for rec in self:
            ico_inv = rec.intercompany_invoice_id or rec.auto_invoice_id
            if ico_inv:
                state_selection = rec.fields_get(allfields="state")["state"][
                    "selection"
                ]
                state_ui = [x for x in state_selection if x[0] == ico_inv.state][0][1]
                ref = ico_inv.name + " (" + _("State") + ": " + state_ui + ")"
                rec.intercompany_invoice_ref = ref
            else:
                rec.intercompany_invoice_ref = False

    def button_draft(self):
        self._check_ico_inv_status()
        return super().button_draft()

    def button_cancel(self):
        self._check_ico_inv_status()
        return super().button_cancel()

    def _check_ico_inv_status(self):
        for rec in self.sudo():
            if rec.move_type in ("out_invoice", "out_refund"):
                ico_inv = rec.intercompany_invoice_id
                if ico_inv and ico_inv.state != "cancel":
                    raise UserError(
                        _(
                            "You can only reset to draft an Intercompany Invoice "
                            "if the associated Supplier Invoice in the "
                            "target company has been set to state 'Cancel'."
                        )
                    )

    def _inter_company_create_invoices(self):
        ico_invs = self.env["account.move"]
        for rec in self:
            ico_inv = super(AccountMove, rec)._inter_company_create_invoices()
            rec.intercompany_invoice_id = ico_inv
            ico_invs += ico_inv
        return ico_invs

    def _inter_company_prepare_invoice_data(self, invoice_type):
        """
        Use this method to customize the selection of the
        incoming invoice journal.
        """
        vals = super()._inter_company_prepare_invoice_data(invoice_type)
        if invoice_type[:2] != "in":
            return vals

        target_company = self.env["res.company"]._find_company_from_partner(
            self.partner_id.id
        )
        mapping = (
            self.env["account.reinvoice.journal.mapping.multi.company"]
            .sudo()
            .search(
                [
                    ("company_id", "=", self.company_id.id),
                    ("target_company", "=", target_company.id),
                ]
            )
        )
        mapping = mapping.filtered(
            lambda r: self.journal_id.id in r.journal_out_ids.ids
        )
        if len(mapping) == 1:
            if invoice_type == "in_invoice":
                journal = mapping.target_journal_id
            else:
                journal = mapping.target_refund_journal_id
            vals["journal_id"]: journal.id

        return vals
