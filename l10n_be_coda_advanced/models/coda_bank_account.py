# Copyright 2009-2021 Noviat.
# License AGPL-3.0 or later (http://www.gnu.org/licenses/agpl).

from odoo import _, api, fields, models
from odoo.exceptions import ValidationError


class CodaBankAccount(models.Model):
    _name = "coda.bank.account"
    _description = "CODA Bank Account Configuration"
    _order = "name"
    _sql_constraints = [
        (
            "account_uniq_1",
            "unique (journal_id, description1, currency_id)",
            "The combination of Bank Account, Primary Account Description "
            "and Currency must be unique !",
        ),
        (
            "account_uniq_2",
            "unique (journal_id, description2, currency_id)",
            "The combination of Bank Account, Secondary Account Description "
            "and Currency must be unique !",
        ),
    ]

    name = fields.Char(string="Name", required=True)
    description1 = fields.Char(
        string="Primary Account Description",
        size=35,
        help="The Primary or Secondary Account Description should match "
        "the corresponding Account Description in the CODA file.",
    )
    description2 = fields.Char(
        string="Secondary Account Description",
        size=35,
        help="The Primary or Secondary Account Description should match "
        "the corresponding Account Description in the CODA file.",
    )
    journal_id = fields.Many2one(
        comodel_name="account.journal",
        string="Journal",
        domain="[('type', '=', 'bank'), ('company_id', 'in', allowed_company_ids)]",
        copy=False,
        required=True,
        help="Bank Journal for the Bank Statement",
    )
    bank_id = fields.Many2one(
        comodel_name="res.partner.bank",
        string="Bank Account",
        readonly=True,
        related="journal_id.bank_account_id",
        help="Bank Account Number.\nThe CODA import function will "
        "find its CODA processing parameters on this number.",
    )
    currency_id = fields.Many2one(
        comodel_name="res.currency",
        string="Currency",
        compute="_compute_currency_id",
        store=True,
        readonly=True,
        help="The currency of the CODA Bank Statement",
    )
    coda_st_naming = fields.Char(
        string="Bank Statement Naming Policy",
        size=64,
        default="%(code)s-%(y)s-%(coda)s",
        help="Define the rules to create the name of the Bank Statements "
        "generated by the CODA processing."
        "\nE.g. %(code)s%(y)s/%(paper)s"
        "\n\nVariables:"
        "\nBank Journal Code: %(code)s"
        "\nYear (of CODA 'New Balance Date') with Century: %(year)s"
        "\nYear (of CODA 'New Balance Date') without Century: %(y)s"
        "\nCODA sequence number: %(coda)s"
        "\nPaper Statement sequence number "
        "(as specified on 'Old Balance' record): %(paper_ob)s"
        "\nPaper Statement sequence number "
        "(as specified on 'New Balance' record): %(paper)s",
    )
    transfer_account_id = fields.Many2one(
        comodel_name="account.account",
        string="Internal Funds Transfer Account",
        domain="[('code', '=like', '58%'), ('company_id', '=', company_id)]",
        required=True,
        help="Set here the default account that will be used for "
        "internal transfer between own bank accounts "
        "(e.g. transfer between current and deposit bank accounts).",
    )
    account_mapping_ids = fields.One2many(
        comodel_name="coda.account.mapping.rule",
        inverse_name="coda_bank_account_id",
        string="Account Mapping Rules",
    )
    find_bbacom = fields.Boolean(
        string="Lookup Structured Communication of type 'BBA'",
        default=True,
        help="Partner lookup and reconciliation "
        "via the 'BBA' Structured Communication."
        "'\nA partial reconciliation will be created when there is "
        "no exact match between the Invoice "
        "and Bank Transaction amounts.",
    )
    find_inv_number = fields.Boolean(
        string="Lookup Invoice Number",
        default=True,
        help="Partner lookup and reconciliation via the Invoice Number "
        "when a communication in free format is used."
        "\nA reconciliation will only be created in case of "
        "exact match between the Invoice and "
        "Bank Transaction amounts.",
    )
    find_account_move_line = fields.Boolean(
        string="Lookup Accounting Entries",
        default=False,  # default = False since this lookup may burn resources
        help="Find matching accounting entry when previous lookups "
        "(payment order, invoice, sales order) have failed."
        "\nThis allows e.g. to match with manually encoded "
        "accounting entries (journal item 'name' field combined "
        "exact match on amount) or non payable/receivable entries.",
    )
    find_partner = fields.Boolean(
        string="Lookup Partner",
        default=True,
        help="Partner lookup via Bank Account Number "
        "in order to facilitate the reconciliation.",
    )
    update_partner = fields.Boolean(
        string="Update Partner Bank Accounts",
        default=True,
        help="Update Partner record when the Counterparty's Bank Account "
        "has not been registered yet.",
    )
    balance_start_enforce = fields.Boolean(
        string="Prevent invalid Opening Balances",
        default=True,
        help="Do not process Statements with an Opening Balance that "
        "doesn't match the previous Closing Balance.",
    )
    discard_dup = fields.Boolean(
        string="Discard Duplicates",
        help="Duplicate Bank Statements will be discarded. "
        "Select the corresponding 'CODA Bank Statement' in order "
        "to view the contents of such duplicates.",
    )
    active = fields.Boolean(
        string="Active",
        default=True,
        help="If the active field is set to False, "
        "it will allow you to hide the "
        "CODA Bank Account Configuration without removing it.",
    )
    company_id = fields.Many2one(
        string="Company",
        store=True,
        readonly=True,
        related="journal_id.company_id",
        change_default=True,
    )
    display_name = fields.Char(
        compute="_compute_display_name",
        string="Display Name",
        store=True,
        readonly=True,
    )

    @api.depends("journal_id")
    def _compute_currency_id(self):
        for rec in self:
            if rec.journal_id:
                aa = rec.journal_id.default_debit_account_id
                if not aa:
                    raise ValidationError(
                        _(
                            "Configuration error !\n"
                            "No 'Default Debit Account' defined on the selected Journal"
                        )
                    )
                rec.currency_id = (
                    aa.currency_id or rec.journal_id.company_id.currency_id
                )

    @api.depends("bank_id", "currency_id", "description1")
    def _compute_display_name(self):
        for rec in self:
            if not rec.bank_id.acc_number:
                raise ValidationError(
                    _(
                        "Configuration error !\n"
                        "No Bank Account Number defined on the selected Journal"
                    )
                )
            else:
                display_name = (
                    rec.bank_id.acc_number + " (" + rec.currency_id.name + ")"
                )
            if rec.description1:
                display_name += " " + rec.description1
            rec.display_name = (
                len(display_name) > 55 and display_name[:55] + "..." or display_name
            )

    @api.onchange("journal_id")
    def _onchange_journal_id(self):
        if not self.bank_id.acc_number:
            raise ValidationError(
                _(
                    "Configuration error !\n"
                    "No Bank Account Number defined on the selected Journal"
                )
            )
        self.transfer_account_id = self.journal_id.company_id.transfer_account_id

    def copy(self, default=None):
        default = dict(default or {})
        default.update(
            {
                "journal_id": False,
                "name": (self.name or "") + " (copy)",
                "description1": (self.description1 or "") + " (copy)",
                "description2": (self.description2 or "") + " (copy)",
            }
        )
        return super().copy(default)
